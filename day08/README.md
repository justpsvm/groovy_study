## 闭包的便利性


> 普通函数需要完成明确的任务时应该优于闭包，重构代码的过程使用闭包才是好时机 而不是一开始就需要强制性使用闭包。

这是因为只有重新审视/优化/重构代码时 才知道哪些地方可以使用闭包替代 闭包的使用就应该在这种过程中浮现出来。

groovy 中的闭包避免了代码的冗余，而且可轻松创建轻量级 可复用的代码片段。


```groovy
def sum = 0
for(i in 1..10){
	if(i % 2 == 0){
		sum += i
	}
}

println "sum: $sum"
```

这里是一段从 1-10 数字中 累积偶数的和 代码看起来没有任务问题，不过现在需要更改为: 积累偶数的乘积 如果修改?

一般的 我们会这样进行修改:

```groovy
def sum = 0
for(i in 1..10){
	if(i % 2 != 0){
		sum *= i
	}
}

println "sum: $sum"
```

尽管如此，代码还是有冗余的地方，在循环的地方重复性代码太多，接下来使用`闭包的方式`重构下代码:


```groovy
def total(i,event){
	for(def j = 1; j <= i; j++){
		if(j % 2 == 0) event(j)
	}
}

def sum = 0
total(10){sum += it}

println "sum: $sum"
```

这里通过定义 `total` 函数，使用 `event` 代表传递一个方法，也就是说这里的参数实际可以传递函数过来，在循环的过程中把值传递给了一个代码块。

> 在 groovy 中，这种代码称为闭包。

闭包可以通过参数进行传递，闭包参数可以是很多个，如果最后一个参数是闭包的时候 可以通过下面的这种写法:

```groovy
fun(param){}
```

groovy 会自动把最后的 `{}` 看做一个闭包 并传递到方法的最后一个参数中。

上面的代码中使用到了 `it` 这个变量，如果你的闭包只接收了一个参数 那么可以使用 `it` 来接收，你也可以通过其它的参数来接收:

```groovy
total(10){number -> sum += number}
```

## 闭包的使用方式

闭包能够扩充/优化或增强另一段代码，闭包有两个非常擅长的领域:

- 辅助资源清理
- 辅助创建内部的特定语言(DSL)


### 使用参数传递闭包

比如在上面的例子中 这里就不重复了。

### 闭包赋值给变量复用

```groovy
def isHandle = {it % 2 == 0}

def total(event){
	for(i in 1..10){
		if(event(i)){
			println i
		}
	}
}

total(isHandle)
```

输出结果:

```bash
2
4
6
8
10
```
> 把 1-10 之内的偶数输出出来。

这里把闭包传递给了 `isHandle` 的函数，之后在函数内部调用闭包处理过后的返回值进行输出。

之前说过 如果闭包的参数时最后一个 你也可以这样写:

```groovy
```groovy
def total(event){
	for(i in 1..10){
		if(event(i)){
			println i
		}
	}
}

total(){it % 2 == 0}
```

这种方式是预先定义闭包，将闭包缓存下来 在需要使用的地方进行复用。


## 向闭包传递参数

之前有说过:`如果闭包只有一个参数的时候 可以使用 it` 代替变量，现在看看多个参数是如何处理的:

```groovy
def info(call){
	call "张三",20
}

info(){name,age ->
	println "姓名: $name,年龄: $age"
}
```

结果:

```bash
姓名: 张三,年龄: 20
```

在闭包需要传递多个参数时，可以指定相应的变量来接收它们。

> 需要注意的是 闭包传递的参数和接收处理的参数个数必须是一致的 否则会抛出异常。
